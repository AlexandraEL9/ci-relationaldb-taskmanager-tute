------------------------lesson4- Template inheritance
-Parent and child HTML templates.
-The child template inherits HTML code from the parent template. This follows the 
 philosophy of 'DRY - Don't Repeat Yourself' as templating helps you avoid duplication.
 -You use jinja blocks to inject content e.g.
{% block content %} *Insert content here* {% endblock %}

Before we can do any data manipulation using CRUD functionality, we need some sort of front-end
user interface to interact with the database.

If you recall from the previous lessons using Flask on the Thorin project, we used something called template inheritance.
This allows us to extend various HTML templates, to avoid duplicating code, such as a navbar
or footer that's identical across all pages.

Also, in the introduction video, we discussed the use of a CSS framework called Materialize,
which we will be using throughout this project.


This will allow us to make use of their responsive behaviors using the grid system, similar to
Bootstrap, and various components to make our application more user-friendly.
At the time of recording, the latest version of Materialize is 1.0.0 as you can see in the top-left corner of their site.
The first thing that we need to do, is to grab the CDN link and script tags from the 'Getting Started' page.
We'll paste the CSS link within our base template head element, and then paste the JavaScript
script tag at the bottom of our body element.
With Materialize, you can use their components with or without jQuery, so if you decide to
use jQuery, you'll want to include that just before the Materialize script.
In addition to using Materialize, we are going to incorporate some of our own custom CSS and JavaScript.
When using a templating language such as Flask, any assets that we use such as images, CSS,
and JavaScript, need to be stored in a directory called 'static'.
Let's create this new folder within our taskmanager package, and we'll also want to add the css/
and js/ folders within this static directory.
As with tradition, we'll call our CSS file 'style.css', and our JavaScript file 'script.js' in their respective folders.
Now, in order to link to any static file that we have, it's important to note that we must use the correct syntax.
You should be rather familiar with just adding the standard front-end method.
However, with templating languages, this method can cause errors or the files not loading properly.
We must use double curly brackets, and then use the 'url_for()' method, which takes two values.
The first value is the 'static' directory, so it knows to look within this main folder.
Separate the values with a comma, then we need to use filename='css/style.css', and
make sure to watch out for the double vs single quotes.
As you can see, I'm using the double-quotes to wrap the entire href property.
Then, for anything within the href, I've used single-quotes, because by using double-quotes
again, it will think that our href is finished, and throw a syntax error.
Let's do the same exact thing for our JavaScript file.
The script source will use double-quotes, wrapping everything in double curly-brackets,
and the url_for() method points to our static file in single-quotes.
Then, a comma to separate the filename, which is equal to 'js/script.js' in single-quotes,
pointing to our js/ folder and the file itself.
You don't need to use this method for any external CDN links, such as the Materialize links for example.
It's only needed for any files that we actually own within our workspace or project, including images.
This is due to the fact that you’re working with a framework, which relies on using “url_for()”
methods to find the relevant files locally to your own project.
Also, quite often when working with a templating language, if you make changes to your CSS
or JavaScript files, and then reload the page, it might not show your changes.
This is very likely an issue to do with caching, so here are three steps to always remember to check.
First, try a hard-reload, which is generally CTRL+SHIFT+R in most cases, but depending
on your computer and which browser you use, it could be one of these combinations on screen.
Second, if that doesn't work, open a new Incognito window with your project URL, and if you do
see the changes, it's certainly a caching issue, since Incognito doesn't store cache.
Finally, if neither of those options work, stop the application in your terminal from
running, and just restart it.
This may sound asinine, but quite often with Flask and Django, a fresh restart of the app
is required to take effect of any new additions to your code.
Now that we have our static files connected to the base template, let's start adding a
few components, such as a navbar.
From the Materialize docs, click on Components to expand it, then click Navbar.
We'll be using the Mobile Collapse option, which will make a responsive navbar for smaller screens.
Copy the code, and let's paste this within a header tag, which will replace our text of 'Hello World'.
The reason why it shows the unordered list twice, is because one is for the navbar on
the top of the page, and the other is for our mobile side navbar.
If you recall from the introduction video, Materialize has a variety of colors to choose
from, whether it's for text or elements.
I'm going to change the default pink navbar to include a class of light-blue darken-1,
but feel free to use any color you’d like.
For the logo, we'll just call the project Task Manager, and have it load our main page when clicked.
Similar to our static files, we need to use the url_for() method for any links within our project.
Double curly-brackets, url_for(), and then in single-quotes the name of our Python function to call, which is 'home'.
If you recall from our routes.py file, this is the only route that we've created so far,
and we've called it 'home', which will render the base.html template.
We don't need to include the 'static' or 'filename' properties, since this is calling an actual function.
Again, using this approach is very important, so if you only type href="base.html", then
your project won't compile properly by Flask, and you'll likely get an error.
We're going to have 3 links within our navbar, so we'll remove their sample links.
These links will be: Home, New Task, and Categories.
We already have the function created for our 'Home' link, so we can copy that, and paste it within the hrefs.
Since we haven't created the other two functions or routes yet, then we cannot include those as placeholder links.
If we try to load the site using placeholder links, Flask will throw an error saying that
it can't find the intended function you're attempting to call.
For the mobile menu icon, the Materialize docs include Google's Material Design icons,
so you're welcome to those as well, but be sure to include the CDN link from the 'Icons' page.
However, Font-Awesome contains over a thousand more icons to choose from, so I'll include
the Font-Awesome CDN link from the CDNJS library site.
I'll copy the link tag, and paste it within my head element before the Materialize CDN
link, then replace the menu icon with a Font-Awesome icon instead.
Next, even though we don't have the Python functions created, I'm going to duplicate
the Home link, and create empty links for the others now.
The second link will be for adding a New Task, and the final link will be for all Categories.
Remember, these need to be blank href links for now, so we'll delete the paths, and then
we can go ahead and copy these two new links, then paste them below in the sidenav list.
In order for the sidenav to work, we need to initialize the JavaScript functionality from Materialize.
Let's copy the initialization code, either the vanilla JavaScript snippet, or if you're
using jQuery, the snippet below, then let's paste it within our script.js file.
We are actually going to be using a few different elements from Materialize, so let's give our
variables a more unique name.
The querySelector will be 'sidenav', and then we'll just initialize that without defining any variable.
The next section will be where all of our main content will be injected, so we'll use
the Template Inheritance {% block %} element.
Let's wrap this inside of a semantic main element with the Materialize class of 'container'.
In exactly the same way that we did on our previous Flask lessons, we'll call this block
element 'content', making sure to close the {% endblock %} tag as well.
Before we create any template that extends this, we'll quickly add a Materialize footer.
Paste the footer below the main element, and you can style this any way you'd like,
but I'll keep it simple and clean by removing some unnecessary bulk.
It'll be 'blue darken-3', removing the container link section, adding 'For educational purposes
only', then a link to Code Institute in a new blank tab.
Since we've been using semantic HTML elements such as header, nav, main, and footer, we
can simply force the footer to stay at the bottom of the page by using the 'Sticky Footer' CSS code.
Paste that into your CSS file, and this will make the footer always stay at the bottom
of the page, no matter how much or how little content is on each page.
Now we can start using the template inheritance functionality, and extend our base template across various files.
Let's create a new template in the templates directory, and call it 'tasks.html', which
is where we will display any task that will be stored within our database later.
This will use the {% extends %} block, which will extend our base.html template.
This means that by extending from the base template, anything created on our base template
will display on this page as well, which includes our navbar and footer.
Then, we'll inject anything from this tasks template into the 'content' block element,
making sure to close the {% endblock %} as well.
We will add the content for this page in a later video, so for now, let's simply just
add an h3 element for 'Tasks', with some of the Materialize helper classes.
Finally, let's go back to our routes.py file, and update the rendered template to be 'tasks.html' instead.
This will become our home page now, so that when a user visits our site, they're brought
to the tasks page, which will automatically extend all of the content from our base template.
Save all of your files, and if your app isn't currently running, go ahead and start it within
the terminal by typing 'python3 run.py' and then open your browser.
Remember to hard-reload the page or use Incognito Mode if your static files with the CSS or
JavaScript aren't working for you, otherwise check for a possible typo on your code.
Everything looks great so far, and behaves as expected, even our mobile navbar if we
decrease the width of the page.
We now have the basic front-end template set up with a navbar, a footer, and a tasks template
that uses Template Inheritance to extend from the base file.
In the next lesson, we are going to start working with the database, and performing some CRUD functionality.
For now, go ahead and push your code to GitHub, and I'll see you on the next video.